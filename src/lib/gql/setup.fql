// * Schema must be uploaded before running setup script!
// * Please run blocks one at a time to prevent race conditions, or use `Do` to execute them in order.

// Auth

// Login with only email, for User collection/type
Update(Function('login_user'), {
  body: Query(
    Lambda(
      ['input'],
      // Auth and user info payload
      Let(
        {
          // Let() declarations evaluate variable expressions in order, like Do()
          userMatch: Match(Index('unique_User_email'), Select('email', Var('input'))),
          // Create user if doesn't exist
          userRef: If(
            IsNonEmpty(Var('userMatch')),
            Select('ref', Get(Var('userMatch'))),
            Select(
              'ref',
              Create(Collection('User'), {
                // ⚙ User creation defaults
                data: Merge(Var('input'), { onboard: true, created: Now() }),
              })
            )
          ),
          tokenDoc: Create(Tokens(), {
            instance: Var('userRef'),
            // ⚙ Access token expiry
            // ? Need a shorter active token expiry? Typically secure apps go 10m/20m/1hr, if user data security
            ttl: TimeAdd(Now(), 30, 'days'), //? doesn't matter in your app, you can increase the access token duration.
          }),
        },
        {
          userInfo: Var('userRef'), // Fauna GraphQL API codegens Get() using doc ref of the type/collection
          exp: Select('ttl', Var('tokenDoc')),
          token: Select('secret', Var('tokenDoc')),
        }
      )
    )
  ),
})

// Internal index that returns who the user is following rather than the Follow doc by auto-generated FQL via SDL
// This is almost always the desired behavior when searching for all the people the user follows.
CreateIndex({
  name: '_following_by_user',
  unique: false,
  serialized: true,
  source: Collection('Follow'),
  terms: [
    {
      field: ['data', 'user'],
    },
  ],
  values: [
    {
      field: ['data', 'follows'],
    },
  ],
})

// ? If reusable code desired, can abstract this UDF into a more general UDF that takes the size, after, before, & `match` as a variable and invoke it.
Update(Function('get_timeline'), {
  body: Query(
    Lambda(
      ['size', 'after', 'before'],
      Let(
        {
          match: Reverse(Join(Match(Index('_following_by_user'), Identity()), Index('photo_author_by_user'))),
          page: If(
            Equals(Var('before'), null),
            If(
              Equals(Var('after'), null),
              Paginate(Var('match'), { size: Var('size') }),
              Paginate(Var('match'), { size: Var('size'), after: Var('after') })
            ),
            Paginate(Var('match'), { size: Var('size'), before: Var('before') })
          ),
        },
        Map(
          Var('page'),
          // Lambdas take an expression to return as second arg, in this case we're creating an obj as the expression
          Lambda('ref', { photo: Var('ref'), likeCount: Count(Match(Index('photo_liked_by_photo'), Var('ref'))) })
        )
      )
    )
  ),
})

// Basically same UDF as get_timeline, but with a match on the entire Photo collection, reversed.
Update(Function('get_explore'), {
  body: Query(
    Lambda(
      ['size', 'after', 'before'],
      Let(
        {
          match: Reverse(Documents(Collection('Photo'))),
          page: If(
            Equals(Var('before'), null),
            If(
              Equals(Var('after'), null),
              Paginate(Var('match'), { size: Var('size') }),
              Paginate(Var('match'), { size: Var('size'), after: Var('after') })
            ),
            Paginate(Var('match'), { size: Var('size'), before: Var('before') })
          ),
        },
        Map(
          Var('page'),
          Lambda('ref', { photo: Var('ref'), likeCount: Count(Match(Index('photo_liked_by_photo'), Var('ref'))) })
        )
      )
    )
  ),
})
