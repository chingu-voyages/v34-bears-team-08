// * Schema must be uploaded before running setup script!
// * Please run blocks one at a time to prevent race conditions, or use `Do` to execute them in order.

// * Tip: To easily format for Do in VSCode, wrap all in Do(), then select a closing parens + whitespace and ctrl+shift+l
// * to get all cursors. Finally add the comma.

// Auth

// Login with only email, for User collection/type
Update(Function('login_user'), {
  body: Query(
    Lambda(
      ['input'],
      // Auth and user info payload
      Let(
        {
          // Let() declarations evaluate variable expressions in order, like Do()
          userMatch: Match(Index('unique_User_email'), Select('email', Var('input'))),
          // Create user if doesn't exist
          userRef: If(
            IsNonEmpty(Var('userMatch')),
            Select('ref', Get(Var('userMatch'))),
            Select(
              'ref',
              Create(Collection('User'), {
                // ⚙ User creation defaults
                data: Merge(Var('input'), { onboard: true, created: Now() }),
              })
            )
          ),
          tokenDoc: Create(Tokens(), {
            instance: Var('userRef'),
            // ⚙ Access token expiry
            // ? Need a shorter active token expiry? Typically secure apps go 10m/20m/1hr, if user data security
            ttl: TimeAdd(Now(), 30, 'days'), //? doesn't matter in your app, you can increase the access token duration.
          }),
        },
        {
          userInfo: Var('userRef'), // Fauna GraphQL API codegens Get() using doc ref of the type/collection
          exp: Select('ttl', Var('tokenDoc')),
          token: Select('secret', Var('tokenDoc')),
        }
      )
    )
  ),
})

Update(Function('logout_user'), {
  body: Query(Lambda(['input'], Logout(Select('allDevices', Var('input'))))),
})

// Internal index that returns who the user is following rather than the Follow doc by auto-generated FQL via SDL
// This is almost always the desired behavior when searching for all the people the user follows.
CreateIndex({
  name: '_following_by_user',
  unique: false,
  serialized: true,
  source: Collection('Follow'),
  terms: [
    {
      field: ['data', 'user'],
    },
  ],
  values: [
    {
      field: ['data', 'follows'],
    },
  ],
})

// TODO: Paginate may return null results in which case you'd need to Get() the actual data, see get_profile_photos for
// TODO: the logic that does this. Also, test if sending back an obj w/ the ref on it instead of using Get() works.
// ? If reusable code desired, can abstract this UDF into a more general UDF that takes the size, after, before, & `match` as a variable and invoke it.
Update(Function('get_timeline'), {
  body: Query(
    Lambda(
      ['size', 'after', 'before'],
      Let(
        {
          match: Reverse(
            Join(
              // Potential optimization incurs significantly more calls and will not be applied here as it handles an edge case.
              // Paginate could be used on these matches to prevent resulting Join set from being too large (100k) if following too many users w/ too many photos.
              Match(Index('_following_by_user'), Identity()),
              Index('photo_author_by_user')
            )
          ),
        },
        // Return page based on supplied pagination args
        Map(
          If(
            Equals(Var('before'), null),
            If(
              Equals(Var('after'), null),
              Paginate(Var('match'), { size: Var('size') }),
              Paginate(Var('match'), { size: Var('size'), after: Var('after') })
            ),
            Paginate(Var('match'), { size: Var('size'), before: Var('before') })
          ),
          Lambda('docRef', Get(Var('docRef')))
        )
      )
    )
  ),
})

// Basically same UDF as get_timeline, but with a match on the entire Photo collection, reversed.
Update(Function('get_explore'), {
  body: Query(
    Lambda(
      ['size', 'after', 'before'],
      Let(
        { match: Reverse(Documents(Collection('Photo'))) },
        Map(
          If(
            Equals(Var('before'), null),
            If(
              Equals(Var('after'), null),
              Paginate(Var('match'), { size: Var('size') }),
              Paginate(Var('match'), { size: Var('size'), after: Var('after') })
            ),
            Paginate(Var('match'), { size: Var('size'), before: Var('before') })
          ),
          Lambda('docRef', Get(Var('docRef')))
        )
      )
    )
  ),
})

Update(Function('get_profile_photos'), {
  body: Query(
    Lambda(
      // yep, with GraphQL paginate: true on resolver, all values defined in schema will be first and any of the paginate
      // variables are after.
      ['id', 'size', 'after', 'before'],
      Let(
        { match: Reverse(Match(Index('user_photos_by_user'), Ref(Collection('User'), Var('id')))) },
        Map(
          If(
            Equals(Var('before'), null),
            If(
              Equals(Var('after'), null),
              Paginate(Var('match'), { size: Var('size') }),
              Paginate(Var('match'), { size: Var('size'), after: Var('after') })
            ),
            Paginate(Var('match'), { size: Var('size'), before: Var('before') })
          ),
          Lambda('docRef', Get(Var('docRef')))
        )
      )
    )
  ),
})

Update(Function('like_photo'), {
  body: Query(
    Lambda(
      'input',
      Let(
        {
          photoRef: Ref(Collection('Photo'), Select('photoID', Var('input'))),
          likedMatch: Match(Index('photo_liked_by_photo_and_user'), [Var('photoRef'), Identity()]),
        },
        Do(
          // Create likes
          If(
            Select('value', Var('input')),
            // like
            If(
              Exists(Var('likedMatch')),
              null,
              Create(Collection('photo_liked'), {
                data: {
                  userID: Identity(),
                  photoID: Var('photoRef'),
                },
              })
            ),
            // unlike
            If(Exists(Var('likedMatch')), Delete(Select('ref', Get(Var('likedMatch')))), null)
          ),
          // Update likeCount on photo
          Update(Var('photoRef'), {
            data: { likeCount: Count(Match(Index('photo_liked_by_photo'), Var('photoRef'))) },
          })
        )
      )
    )
  ),
})

Update(Function('follow_user'), {
  body: Query(
    Lambda(
      'input',
      Let(
        {
          userRef: Ref(Collection('User'), Select('userID', Var('input'))),
          // all the users the user is following
          followingMatch: Match(Index('following_by_user'), Identity()),
          // all users following who the user is trying to follow
          followersMatch: Match(Index('followers_by_user'), Var('userRef')),
          // check if the user is already following, however we're not creating a new index with multiple match terms
          followMatch: Intersection(Var('followingMatch'), Var('followersMatch')),
        },
        Do(
          // Create Follow doc
          If(
            Select('value', Var('input')),
            // follow
            If(
              Exists(Var('followMatch')),
              null,
              Create(Collection('Follow'), {
                data: {
                  user: Identity(),
                  follows: Var('userRef'),
                },
              })
            ),
            // unfollow
            If(Exists(Var('followMatch')), Delete(Select('ref', Get(Var('followMatch')))), null)
          ),
          // Update followerCount and followingCount on both user and who they're following
          Do(
            Update(Identity(), {
              data: { followingCount: Count(Var('followingMatch')) },
            }),
            Update(Var('userRef'), {
              data: { followerCount: Count(Var('followersMatch')) },
            })
          )
        )
      )
    )
  ),
})
