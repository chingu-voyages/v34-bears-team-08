// * Schema must be uploaded before running setup script!
// * Please run blocks one at a time to prevent race conditions, or use `Do` to execute them in order.

/* VSCode Fauna (+extension) tips
Easily format for Do: wrap all in Do(), then select a closing parens + whitespace and ctrl+shift+l to get all cursors. 
Finally add the comma.
Must have ext and .faunarc w/ key for below:
Running queries from Fauna FQL files: Regex replace comments: //.+ (Create Query -> Copy/Paste -> Replace -> Run 
Query/CTRL+Enter)
*/

// Auth

// Login with only email, for User collection/type
Update(Function('login_user'), {
  body: Query(
    Lambda(
      ['input'],
      // Auth and user info payload
      Let(
        {
          // Let() declarations evaluate variable expressions in order, like Do()
          userMatch: Match(Index('unique_User_email'), Select('email', Var('input'))),
          // Create user if doesn't exist
          userRef: If(
            IsNonEmpty(Var('userMatch')),
            Select('ref', Get(Var('userMatch'))),
            Select(
              'ref',
              Create(Collection('User'), {
                // ⚙ User creation defaults
                data: Merge(Var('input'), { onboard: true, created: Now() }),
              })
            )
          ),
          tokenDoc: Create(Tokens(), {
            instance: Var('userRef'),
            // ⚙ Access token expiry
            // ? Need a shorter active token expiry? Typically secure apps go 10m/20m/1hr, if user data security
            ttl: TimeAdd(Now(), 30, 'days'), //? doesn't matter in your app, you can increase the access token duration.
          }),
        },
        {
          userInfo: Var('userRef'), // Fauna GraphQL API codegens Get() using doc ref of the type/collection
          exp: Select('ttl', Var('tokenDoc')),
          token: Select('secret', Var('tokenDoc')),
        }
      )
    )
  ),
})

Update(Function('logout_user'), {
  body: Query(Lambda(['input'], Logout(Select('allDevices', Var('input'))))),
})

// Internal index that returns who the user is following rather than the Follow doc by auto-generated FQL via SDL
// This is almost always the desired behavior when searching for all the people the user follows.
CreateIndex({
  name: '_following_by_user',
  unique: false,
  serialized: true,
  source: Collection('Follow'),
  terms: [
    {
      field: ['data', 'user'],
    },
  ],
  values: [
    {
      field: ['data', 'follows'],
    },
  ],
})

// TODO: Paginate may return null results in which case you'd need to Get() the actual data, see get_profile_photos for
// TODO: the logic that does this. Also, test if sending back an obj w/ the ref on it instead of using Get() works.
// ? If reusable code desired, can abstract this UDF into a more general UDF that takes the size, after, before, & `match` as a variable and invoke it.
Update(Function('get_timeline'), {
  body: Query(
    Lambda(
      ['size', 'after', 'before'],
      Let(
        {
          match: Reverse(
            Join(
              // Potential optimization incurs significantly more calls and will not be applied here as it handles an edge case.
              // Paginate could be used on these matches to prevent resulting Join set from being too large (100k) if following too many users w/ too many photos.
              Match(Index('_following_by_user'), CurrentIdentity()),
              Index('photo_author_by_user')
            )
          ),
        },
        // Return page based on supplied pagination args
        Map(
          If(
            Equals(Var('before'), null),
            If(
              Equals(Var('after'), null),
              Paginate(Var('match'), { size: Var('size') }),
              Paginate(Var('match'), { size: Var('size'), after: Var('after') })
            ),
            Paginate(Var('match'), { size: Var('size'), before: Var('before') })
          ),
          Lambda('docRef', Get(Var('docRef')))
        )
      )
    )
  ),
})

// Basically same UDF as get_timeline, but with a match on the entire Photo collection, reversed.
Update(Function('get_explore'), {
  body: Query(
    Lambda(
      ['size', 'after', 'before'],
      Let(
        { match: Reverse(Documents(Collection('Photo'))) },
        Map(
          If(
            Equals(Var('before'), null),
            If(
              Equals(Var('after'), null),
              Paginate(Var('match'), { size: Var('size') }),
              Paginate(Var('match'), { size: Var('size'), after: Var('after') })
            ),
            Paginate(Var('match'), { size: Var('size'), before: Var('before') })
          ),
          Lambda('docRef', Get(Var('docRef')))
        )
      )
    )
  ),
})

Update(Function('get_user_by_username'), {
  body: Query(Lambda(['username'], Get(Match(Index('unique_User_username'), Var('username'))))),
})

Update(Function('get_profile_photos'), {
  body: Query(
    Lambda(
      // yep, with GraphQL paginate: true on resolver, all values defined in schema will be first and any of the paginate
      // variables are after.
      ['username', 'size', 'after', 'before'],
      Let(
        { match: Reverse(Join(Match(Index('unique_User_username'), Var('username')), Index('user_photos_by_user'))) },
        Map(
          If(
            Equals(Var('before'), null),
            If(
              Equals(Var('after'), null),
              Paginate(Var('match'), { size: Var('size') }),
              Paginate(Var('match'), { size: Var('size'), after: Var('after') })
            ),
            Paginate(Var('match'), { size: Var('size'), before: Var('before') })
          ),
          Lambda('docRef', Get(Var('docRef')))
        )
      )
    )
  ),
})

Update(Function('like_photo'), {
  body: Query(
    Lambda(
      'input',
      Let(
        {
          photoRef: Ref(Collection('Photo'), Select('photoID', Var('input'))),
          likedMatch: Match(Index('photo_liked_by_photo_and_user'), [Var('photoRef'), CurrentIdentity()]),
        },
        Do(
          // Create likes
          If(
            Select('value', Var('input')),
            // like
            If(
              Exists(Var('likedMatch')),
              null,
              Create(Collection('photo_liked'), {
                data: {
                  userID: CurrentIdentity(),
                  photoID: Var('photoRef'),
                },
              })
            ),
            // unlike
            If(Exists(Var('likedMatch')), Delete(Select('ref', Get(Var('likedMatch')))), null)
          ),
          // Update likeCount on photo
          Update(Var('photoRef'), {
            data: { likeCount: Count(Match(Index('photo_liked_by_photo'), Var('photoRef'))) },
          })
        )
      )
    )
  ),
})

Update(Function('follow_user'), {
  body: Query(
    Lambda(
      'input',
      Let(
        {
          userRef: Ref(Collection('User'), Select('userID', Var('input'))),
          // all the users the user is following
          followingMatch: Match(Index('following_by_user'), CurrentIdentity()),
          // all users following who the user is trying to follow
          followersMatch: Match(Index('followers_by_user'), Var('userRef')),
          // check if the user is already following, however we're not creating a new index with multiple match terms
          followMatch: Intersection(Var('followingMatch'), Var('followersMatch')),
        },
        Do(
          // Create Follow doc
          If(
            Select('value', Var('input')),
            // follow
            If(
              Exists(Var('followMatch')),
              null,
              Create(Collection('Follow'), {
                data: {
                  user: CurrentIdentity(),
                  follows: Var('userRef'),
                },
              })
            ),
            // unfollow
            If(Exists(Var('followMatch')), Delete(Select('ref', Get(Var('followMatch')))), null)
          ),
          // Update followerCount and followingCount on both user and who they're following
          Do(
            Update(CurrentIdentity(), {
              data: { followingCount: Count(Var('followingMatch')) },
            }),
            Update(Var('userRef'), {
              data: { followerCount: Count(Var('followersMatch')) },
            })
          )
        )
      )
    )
  ),
})

// ! EXPERIMENTAL

// Methods for getting likedByCurrentUser on a photo
// Method 1: Individual query for getting if a user liked a post. Returns true/false
Update(Function('get_liked_by_current_user'), {
  body: Query(
    Lambda(
      'photoID',
      Exists(
        Match(Index('photo_liked_by_photo_and_user'), [Ref(Collection('photo'), Var('photoID')), CurrentIdentity()])
      )
    )
  ),
})

// Method 2: Append to fetches for photos
// Con: You'll have to update for every query involving returning photo(s). Perhaps a modular UDF could help here.
//      Includes needing to return it for `like_photo` func, allowing it to optimistically update.
// Note: add likedByCurrentUser: Boolean to Photo type field as a placeholder
Example({
  data: {
    likedByCurrentUser: Exists(
      // in some cases, this is likedMatch
      Match(Index('photo_liked_by_photo_and_user'), [Ref(Collection('photo'), Var('photoID')), CurrentIdentity()]),
      // in other cases, it's a photo/doc ref
      Match(Index('photo_liked_by_photo_and_user'), [Var('photoRef'), CurrentIdentity()])
    ),
  },
})
// Either way, you may need to merge the result to create the desired obj
Merge(Var('photoDoc'), {
  data: Merge(Select('data', Var('photoDoc')), { likedByCurrentUser: Var('userLiked') }),
})
